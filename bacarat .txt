<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baccarat P2P - Blockchain Gaming</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #0f1419 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #ffd700, #ff6b35);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .game-table {
            background: radial-gradient(ellipse at center, #0d4f2c 0%, #1a3d29 50%, #0a2818 100%);
            border-radius: 200px 200px 50px 50px;
            padding: 40px;
            margin: 30px auto;
            max-width: 900px;
            border: 8px solid #ffd700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
            position: relative;
        }

        .betting-areas {
            display: flex;
            justify-content: space-around;
            margin-bottom: 40px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .bet-area {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
            position: relative;
            overflow: hidden;
        }

        .bet-area:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
        }

        .bet-area.selected {
            background: linear-gradient(135deg, #ff6b35 0%, #ffd700 100%);
            color: #000;
        }

        .bet-area h3 {
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .bet-amount {
            font-size: 1.1em;
            font-weight: bold;
        }

        .cards-area {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 40px 0;
            flex-wrap: wrap;
            gap: 30px;
        }

        .player-cards, .banker-cards {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .card-section h3 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #ffd700;
        }

        .cards {
            display: flex;
            gap: 10px;
        }

        .card {
            width: 80px;
            height: 120px;
            position: relative;
            margin: 5px;
            perspective: 1000px;
            transform-style: preserve-3d;
            transition: transform 0.6s ease;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s ease;
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 12px;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 8px;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            border: 1px solid rgba(0,0,0,0.1);
        }

        .card-front {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
            color: #333;
            border: 2px solid #ddd;
            transform: rotateY(180deg);
        }

        .card-back {
            background: linear-gradient(145deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: 2px solid #ffd700;
        }

        .card-back::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
        }

        .card-back::after {
            content: '‚ô†‚ô•‚ô¶‚ô£';
            font-size: 12px;
            letter-spacing: 2px;
            opacity: 0.3;
        }

        .card.red .card-front {
            color: #d63031;
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card:hover {
            transform: translateY(-5px) rotateX(5deg);
        }

        .card-rank-top {
            font-size: 18px;
            line-height: 1;
        }

        .card-suit-center {
            font-size: 32px;
            text-align: center;
            margin: 10px 0;
        }

        .card-rank-bottom {
            font-size: 18px;
            line-height: 1;
            transform: rotate(180deg);
            text-align: right;
        }

        .deck-area {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px;
            height: 120px;
        }

        .deck-card {
            position: absolute;
            width: 80px;
            height: 120px;
            background: linear-gradient(145deg, #1e3c72 0%, #2a5298 100%);
            border: 2px solid #ffd700;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .deck-card:nth-child(1) { transform: translateY(0px) translateX(0px); }
        .deck-card:nth-child(2) { transform: translateY(-2px) translateX(-1px); }
        .deck-card:nth-child(3) { transform: translateY(-4px) translateX(-2px); }
        .deck-card:nth-child(4) { transform: translateY(-6px) translateX(-3px); }
        .deck-card:nth-child(5) { transform: translateY(-8px) translateX(-4px); }

        .score {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
            margin-top: 10px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);
            color: white;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info-card h4 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .betting-input {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .betting-input input {
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 16px;
            width: 150px;
        }

        .betting-input input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .quick-bet-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .quick-bet {
            padding: 8px 15px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 20px;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quick-bet:hover {
            background: rgba(255, 215, 0, 0.4);
        }

        .result-display {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            border-radius: 15px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-display.winner {
            background: linear-gradient(135deg, #00b894, #00cec9);
            color: white;
        }

        .result-display.loser {
            background: linear-gradient(135deg, #d63031, #e17055);
            color: white;
        }

        .result-display.tie {
            background: linear-gradient(135deg, #fdcb6e, #e17055);
            color: white;
        }

        @keyframes dealFromDeck {
            0% {
                transform: translateX(0) translateY(0) rotateY(0deg) scale(0.8);
                opacity: 1;
            }
            30% {
                transform: translateX(-100px) translateY(-50px) rotateY(90deg) scale(0.9);
                opacity: 0.8;
            }
            70% {
                transform: translateX(-200px) translateY(-20px) rotateY(170deg) scale(1);
                opacity: 0.9;
            }
            100% {
                transform: translateX(-300px) translateY(0) rotateY(180deg) scale(1);
                opacity: 1;
            }
        }

        @keyframes flipCard {
            0% {
                transform: rotateY(180deg);
            }
            100% {
                transform: rotateY(0deg);
            }
        }

        .card.dealing {
            animation: dealFromDeck 1s ease-out;
        }

        .card.flipping {
            animation: flipCard 0.6s ease-out 1s forwards;
        }

        .dealer-hand {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 150px;
            pointer-events: none;
            z-index: 100;
        }

        .dealing-card {
            position: absolute;
            width: 80px;
            height: 120px;
            background: linear-gradient(145deg, #1e3c72 0%, #2a5298 100%);
            border: 2px solid #ffd700;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffd700;
            font-size: 24px;
            opacity: 0;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
            gap: 20px;
        }

        .stat-item {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            min-width: 100px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }

        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: particle-float 2s ease-out forwards;
        }

        .particle.gold {
            background: radial-gradient(circle, #ffd700 0%, #ffed4e 100%);
            box-shadow: 0 0 10px #ffd700;
        }

        .particle.silver {
            background: radial-gradient(circle, #c0c0c0 0%, #e8e8e8 100%);
            box-shadow: 0 0 8px #c0c0c0;
        }

        .particle.red {
            background: radial-gradient(circle, #ff6b6b 0%, #ff5252 100%);
            box-shadow: 0 0 8px #ff6b6b;
        }

        @keyframes particle-float {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translateY(-100px) scale(0.8);
                opacity: 0.7;
            }
            100% {
                transform: translateY(-200px) scale(0.3);
                opacity: 0;
            }
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd700;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .winner-glow {
            animation: winner-pulse 2s ease-in-out infinite;
        }

        @keyframes winner-pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.4);
            }
        }

        .dealing-sound-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .dealing-sound-indicator.active {
            opacity: 1;
            animation: sound-pulse 0.5s ease-out;
        }

        @keyframes sound-pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3);
            }
            100% {
                transform: scale(1);
            }
        }

        .countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .countdown-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .countdown-number {
            font-size: 8rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            animation: countdown-pulse 1s ease-in-out;
        }

        @keyframes countdown-pulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
            .container {
                padding: 10px;
            }
            
            .game-table {
                padding: 20px;
            }
            
            .cards-area {
                flex-direction: column;
                gap: 20px;
            }
            
            .betting-areas {
                flex-direction: column;
                align-items: center;
            }
            
            .bet-area {
                min-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé∞ BACCARAT P2P üé∞</h1>
            <p>Blockchain ‚Ä¢ DAO ‚Ä¢ Peer-to-Peer Betting</p>
        </div>

        <div class="game-info">
            <div class="info-card">
                <h4>üí∞ T·ªïng Pool</h4>
                <div id="totalPool">0 ETH</div>
            </div>
            <div class="info-card">
                <h4>üë• Ng∆∞·ªùi ch∆°i</h4>
                <div id="playersCount">0</div>
            </div>
            <div class="info-card">
                <h4>‚è±Ô∏è Th·ªùi gian c√≤n l·∫°i</h4>
                <div id="timeLeft">30s</div>
            </div>
            <div class="info-card">
                <h4>üè† DAO Fee</h4>
                <div>3%</div>
            </div>
        </div>

        <div class="game-table">
            <div class="betting-areas">
                <div class="bet-area" data-bet="player">
                    <h3>üé≠ PLAYER</h3>
                    <div class="bet-amount" id="playerBet">0 ETH</div>
                    <div style="font-size: 0.9em; margin-top: 5px;">T·ª∑ l·ªá: 1:1</div>
                </div>
                <div class="bet-area" data-bet="tie">
                    <h3>ü§ù TIE</h3>
                    <div class="bet-amount" id="tieBet">0 ETH</div>
                    <div style="font-size: 0.9em; margin-top: 5px;">T·ª∑ l·ªá: 8:1</div>
                </div>
                <div class="bet-area" data-bet="banker">
                    <h3>üè¶ BANKER</h3>
                    <div class="bet-amount" id="bankerBet">0 ETH</div>
                    <div style="font-size: 0.9em; margin-top: 5px;">T·ª∑ l·ªá: 1:1</div>
                </div>
            </div>

            <div class="betting-input">
                <input type="number" id="betAmount" placeholder="S·ªë ETH ƒë·∫∑t c∆∞·ª£c" min="0.01" step="0.01">
            </div>

            <div class="quick-bet-buttons">
                <div class="quick-bet" data-amount="0.1">0.1 ETH</div>
                <div class="quick-bet" data-amount="0.5">0.5 ETH</div>
                <div class="quick-bet" data-amount="1">1 ETH</div>
                <div class="quick-bet" data-amount="5">5 ETH</div>
            </div>

            <div class="cards-area">
                <div class="deck-area">
                    <div class="deck-card"></div>
                    <div class="deck-card"></div>
                    <div class="deck-card"></div>
                    <div class="deck-card"></div>
                    <div class="deck-card"></div>
                </div>

                <div class="dealer-hand" id="dealerHand"></div>

                <div class="player-cards card-section">
                    <h3>üé≠ PLAYER</h3>
                    <div class="cards" id="playerCards"></div>
                    <div class="score" id="playerScore">0</div>
                </div>

                <div class="banker-cards card-section">
                    <h3>üè¶ BANKER</h3>
                    <div class="cards" id="bankerCards"></div>
                    <div class="score" id="bankerScore">0</div>
                </div>
            </div>

            <div class="result-display" id="gameResult">
                Ch·ªù ng∆∞·ªùi ch∆°i ƒë·∫∑t c∆∞·ª£c...
            </div>

            <div class="controls">
                <button class="btn btn-primary" id="dealBtn" disabled>üéØ B·∫ÆT ƒê·∫¶U GAME</button>
                <button class="btn btn-secondary" id="resetBtn">üîÑ RESET</button>
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="playerWins">0</div>
                <div class="stat-label">Player Wins</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="bankerWins">0</div>
                <div class="stat-label">Banker Wins</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="ties">0</div>
                <div class="stat-label">Ties</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalGames">0</div>
                <div class="stat-label">Total Games</div>
            </div>
        </div>
    </div>

    <!-- Countdown Overlay -->
    <div class="countdown-overlay" id="countdownOverlay">
        <div class="countdown-number" id="countdownNumber"></div>
    </div>

    <!-- Personal Message Popup -->
    <div class="personal-message" id="personalMessage">
        <span class="emoji" id="messageEmoji"></span>
        <div id="messageText"></div>
        <div class="amount" id="messageAmount"></div>
    </div>

    <!-- Console Log Display -->
    <button class="console-toggle" onclick="toggleConsole()">üñ•Ô∏è Console</button>
    <div class="console-log" id="consoleLog">
        <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">üé∞ BACCARAT BLOCKCHAIN CONSOLE üé∞</div>
    </div>

    <!-- Sound Indicator -->
    <div class="dealing-sound-indicator" id="soundIndicator">üîä</div>

    <script>
        class BaccaratGame {
            constructor() {
                this.deck = [];
                this.playerCards = [];
                this.bankerCards = [];
                this.bets = {
                    player: 0,
                    banker: 0,
                    tie: 0
                };
                this.selectedBet = null;
                this.gameState = 'betting';
                this.stats = {
                    playerWins: 0,
                    bankerWins: 0,
                    ties: 0,
                    totalGames: 0
                };
                this.timeLeft = 30;
                this.timer = null;
                this.playersCount = 0;
                this.audioContext = null;
                this.sounds = {};
                
                // Player tracking for personalized messages
                this.playerBets = {};
                this.currentGameBets = {};
                
                // Chainlink VRF simulation
                this.vrfRequestId = null;
                this.pendingVRF = false;
                this.vrfResults = [];
                
                this.initializeAudio();
                this.initializeGame();
                this.bindEvents();
                this.startBettingTimer();
                this.initializeConsole();
            }

            initializeConsole() {
                this.consoleLines = [];
                this.addConsoleLog('üöÄ Baccarat P2P Game Initialized', 'success');
                this.addConsoleLog('‚õìÔ∏è Connected to Arbitrum Layer 2', 'info');
                this.addConsoleLog('üîó Chainlink VRF Oracle Ready', 'info');
            }

            addConsoleLog(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logLine = `[${timestamp}] ${message}`;
                
                this.consoleLines.push({ text: logLine, type: type });
                
                // Keep only last 50 lines
                if (this.consoleLines.length > 50) {
                    this.consoleLines.shift();
                }
                
                this.updateConsoleDisplay();
                
                // Also log to browser console for development
                console.log(logLine);
            }

            updateConsoleDisplay() {
                const consoleElement = document.getElementById('consoleLog');
                const logsHtml = this.consoleLines.map(line => 
                    `<div class="log-line ${line.type}">${line.text}</div>`
                ).join('');
                
                consoleElement.innerHTML = `
                    <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">üé∞ BACCARAT BLOCKCHAIN CONSOLE üé∞</div>
                    ${logsHtml}
                `;
                
                // Auto scroll to bottom
                consoleElement.scrollTop = consoleElement.scrollHeight;
            }

            // Simulate Chainlink VRF request for true randomness
            async requestVRFRandomness() {
                this.pendingVRF = true;
                this.vrfRequestId = 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                this.addConsoleLog('üîó Requesting Chainlink VRF randomness...', 'info');
                this.addConsoleLog(`üìã Request ID: ${this.vrfRequestId}`, 'info');
                document.getElementById('gameResult').textContent = 'üîó ƒêang y√™u c·∫ßu random t·ª´ Chainlink VRF...';
                
                // Simulate network delay for VRF
                await this.sleep(2000);
                
                // Simulate VRF response with cryptographically secure randomness
                const vrfResponse = await this.simulateChainlinkVRF();
                
                this.addConsoleLog('‚úÖ VRF Response received from Oracle', 'success');
                this.addConsoleLog(`üîê Block Hash: ${vrfResponse.blockHash.substr(0, 20)}...`, 'info');
                this.addConsoleLog(`‚ö° Gas Used: ${vrfResponse.gasUsed}`, 'info');
                
                document.getElementById('gameResult').textContent = '‚úÖ Nh·∫≠n ƒë∆∞·ª£c k·∫øt qu·∫£ random t·ª´ blockchain!';
                
                this.vrfResults = vrfResponse.randomNumbers;
                this.pendingVRF = false;
                
                return vrfResponse;
            }

            async simulateChainlinkVRF() {
                // Simulate real Chainlink VRF response structure
                const blockHash = '0x' + Array.from({length: 64}, () => Math.floor(Math.random() * 16).toString(16)).join('');
                const vrfProof = '0x' + Array.from({length: 128}, () => Math.floor(Math.random() * 16).toString(16)).join('');
                
                // Generate 10 random numbers for card dealing (more than needed for safety)
                const randomNumbers = [];
                for (let i = 0; i < 10; i++) {
                    // Simulate Chainlink VRF big random number
                    const bigRandomHex = Array.from({length: 64}, () => Math.floor(Math.random() * 16).toString(16)).join('');
                    const randomValue = parseInt(bigRandomHex.substr(0, 8), 16);
                    randomNumbers.push(randomValue);
                }
                
                return {
                    requestId: this.vrfRequestId,
                    blockHash: blockHash,
                    vrfProof: vrfProof,
                    randomNumbers: randomNumbers,
                    gasUsed: '150000',
                    timestamp: Date.now()
                };
            }

            // Create verifiably random deck using VRF results
            createVRFDeck(vrfRandomNumbers) {
                console.log('üé¥ Creating VRF-shuffled deck...');
                
                const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                
                this.deck = [];
                for (let suit of suits) {
                    for (let rank of ranks) {
                        this.deck.push({
                            suit: suit,
                            rank: rank,
                            value: this.getCardValue(rank)
                        });
                    }
                }

                // Shuffle using VRF randomness (Fisher-Yates with VRF)
                let vrfIndex = 0;
                for (let i = this.deck.length - 1; i > 0; i--) {
                    // Use VRF random number instead of Math.random()
                    const vrfRandom = vrfRandomNumbers[vrfIndex % vrfRandomNumbers.length];
                    const j = vrfRandom % (i + 1);
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                    vrfIndex++;
                }
                
                console.log('‚úÖ Deck shuffled with VRF randomness. First 5 cards:', 
                    this.deck.slice(0, 5).map(c => c.rank + c.suit));
            }

            async initializeAudio() {
                try {
                    // Initialize Web Audio API for sound effects
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create sound effects using Web Audio API
                    this.sounds = {
                        cardDeal: this.createCardDealSound(),
                        cardFlip: this.createCardFlipSound(),
                        win: this.createWinSound(),
                        countdown: this.createCountdownSound(),
                        bet: this.createBetSound()
                    };
                } catch (error) {
                    console.log('Audio not supported, using visual indicators only');
                }
            }

            createCardDealSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                    
                    this.showSoundIndicator();
                };
            }

            createCardFlipSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.05);
                    
                    gainNode.gain.setValueAtTime(0.05, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.05);
                };
            }

            createWinSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const frequencies = [523, 659, 784, 1047]; // C, E, G, C
                    frequencies.forEach((freq, index) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime + index * 0.1);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime + index * 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + index * 0.1 + 0.3);
                        
                        oscillator.start(this.audioContext.currentTime + index * 0.1);
                        oscillator.stop(this.audioContext.currentTime + index * 0.1 + 0.3);
                    });
                };
            }

            createCountdownSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.2);
                };
            }

            createBetSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.05, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
            }

            showSoundIndicator() {
                const indicator = document.getElementById('soundIndicator');
                indicator.classList.add('active');
                setTimeout(() => {
                    indicator.classList.remove('active');
                }, 500);
            }

            initializeGame() {
                this.createDeck();
                this.shuffleDeck();
                this.updateDisplay();
            }

            createDeck() {
                const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                
                this.deck = [];
                for (let suit of suits) {
                    for (let rank of ranks) {
                        this.deck.push({
                            suit: suit,
                            rank: rank,
                            value: this.getCardValue(rank)
                        });
                    }
                }
            }

            shuffleDeck() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            getCardValue(rank) {
                if (rank === 'A') return 1;
                if (['J', 'Q', 'K'].includes(rank)) return 0;
                return parseInt(rank);
            }

            calculateScore(cards) {
                return cards.reduce((sum, card) => sum + card.value, 0) % 10;
            }

            bindEvents() {
                // Betting area selection
                document.querySelectorAll('.bet-area').forEach(area => {
                    area.addEventListener('click', (e) => {
                        if (this.gameState !== 'betting') return;
                        
                        console.log('Bet area clicked:', area.dataset.bet);
                        
                        document.querySelectorAll('.bet-area').forEach(a => a.classList.remove('selected'));
                        area.classList.add('selected');
                        this.selectedBet = area.dataset.bet;
                        
                        console.log('Selected bet set to:', this.selectedBet);
                    });
                });

                // Quick bet buttons
                document.querySelectorAll('.quick-bet').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        console.log('Quick bet clicked:', btn.dataset.amount);
                        const amount = btn.dataset.amount;
                        document.getElementById('betAmount').value = amount;
                        
                        // Auto place bet if bet type is selected
                        if (this.selectedBet) {
                            console.log('Auto placing bet after quick bet selection');
                            this.placeBet();
                        }
                    });
                });

                // Place bet when amount is entered and bet type selected
                document.getElementById('betAmount').addEventListener('input', (e) => {
                    console.log('Bet amount input changed:', e.target.value);
                    // Remove auto-place on input to avoid accidental bets
                });

                document.getElementById('betAmount').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        console.log('Enter pressed, attempting to place bet');
                        if (this.selectedBet) {
                            this.placeBet();
                        } else {
                            console.log('No bet type selected!');
                            alert('Vui l√≤ng ch·ªçn Player, Banker ho·∫∑c Tie tr∆∞·ªõc!');
                        }
                    }
                });

                // Deal button
                document.getElementById('dealBtn').addEventListener('click', () => {
                    console.log('Deal button clicked');
                    this.startGame();
                });

                // Reset button
                document.getElementById('resetBtn').addEventListener('click', () => {
                    console.log('Reset button clicked');
                    this.resetGame();
                });
            }

            checkCanPlaceBet() {
                const amount = parseFloat(document.getElementById('betAmount').value);
                if (amount > 0 && this.selectedBet && this.gameState === 'betting') {
                    console.log('Auto placing bet:', amount, 'on', this.selectedBet);
                    this.placeBet();
                }
            }

            placeBet() {
                const amount = parseFloat(document.getElementById('betAmount').value);
                
                this.addConsoleLog(`üéØ Attempting to place bet: ${amount} ETH on ${this.selectedBet}`, 'info');
                
                if (amount > 0 && this.selectedBet && this.gameState === 'betting') {
                    this.bets[this.selectedBet] += amount;
                    this.playersCount++;
                    
                    // Track individual player bet
                    this.currentGameBets[this.selectedBet] = (this.currentGameBets[this.selectedBet] || 0) + amount;
                    
                    document.getElementById('betAmount').value = '';
                    
                    this.addConsoleLog(`‚úÖ Bet placed successfully! ${amount} ETH on ${this.selectedBet.toUpperCase()}`, 'success');
                    this.addConsoleLog(`üí∞ Total pool: ${Object.values(this.bets).reduce((sum, bet) => sum + bet, 0)} ETH`, 'info');
                    
                    this.updateDisplay();
                    
                    // Play bet sound and create particles
                    this.sounds.bet?.();
                    this.createBetParticles();
                    
                    // Enable deal button if there are bets
                    const totalBets = Object.values(this.bets).reduce((sum, bet) => sum + bet, 0);
                    document.getElementById('dealBtn').disabled = totalBets === 0;
                    
                } else {
                    this.addConsoleLog(`‚ùå Cannot place bet - Invalid conditions`, 'error');
                    this.addConsoleLog(`   Amount: ${amount}, Selected: ${this.selectedBet}, State: ${this.gameState}`, 'warning');
                }
            }

            createBetParticles() {
                const betArea = document.querySelector('.bet-area.selected');
                if (!betArea) return;
                
                const rect = betArea.getBoundingClientRect();
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = 'particle gold';
                        particle.style.position = 'fixed';
                        particle.style.left = (rect.left + rect.width/2) + 'px';
                        particle.style.top = (rect.top + rect.height/2) + 'px';
                        particle.style.width = '8px';
                        particle.style.height = '8px';
                        particle.style.zIndex = '1000';
                        
                        // Random direction
                        const angle = (Math.PI * 2 * i) / 6;
                        const distance = 50 + Math.random() * 30;
                        particle.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
                        
                        document.body.appendChild(particle);
                        
                        setTimeout(() => {
                            document.body.removeChild(particle);
                        }, 2000);
                    }, i * 50);
                }
            }

            startBettingTimer() {
                this.timer = setInterval(() => {
                    this.timeLeft--;
                    document.getElementById('timeLeft').textContent = this.timeLeft + 's';
                    
                    // Warning countdown sounds and effects
                    if (this.timeLeft <= 5 && this.timeLeft > 0) {
                        this.sounds.countdown?.();
                        this.showCountdownOverlay(this.timeLeft);
                    }
                    
                    if (this.timeLeft <= 0) {
                        clearInterval(this.timer); // Stop timer immediately
                        this.timeLeft = 0;
                        
                        const totalBets = Object.values(this.bets).reduce((sum, bet) => sum + bet, 0);
                        console.log('Time up! Total bets:', totalBets); // Debug log
                        
                        if (totalBets > 0) {
                            this.showCountdownOverlay('GO!');
                            setTimeout(() => {
                                this.hideCountdownOverlay();
                                this.startGame();
                            }, 1000);
                        } else {
                            // If no bets, add some demo bets and start game anyway
                            console.log('No bets found, adding demo bets...');
                            this.bets.player = 1;
                            this.bets.banker = 1;
                            this.playersCount = 2;
                            this.updateDisplay();
                            
                            this.showCountdownOverlay('GO!');
                            setTimeout(() => {
                                this.hideCountdownOverlay();
                                this.startGame();
                            }, 1000);
                        }
                    }
                }, 1000);
            }

            showCountdownOverlay(text) {
                const overlay = document.getElementById('countdownOverlay');
                const number = document.getElementById('countdownNumber');
                number.textContent = text;
                overlay.classList.add('active');
                
                setTimeout(() => {
                    overlay.classList.remove('active');
                }, 800);
            }

            hideCountdownOverlay() {
                const overlay = document.getElementById('countdownOverlay');
                overlay.classList.remove('active');
            }

            resetTimer() {
                clearInterval(this.timer);
                this.timeLeft = 30;
                document.getElementById('timeLeft').textContent = this.timeLeft + 's';
                this.startBettingTimer();
            }

            async startGame() {
                console.log('Starting game... Current state:', this.gameState);
                
                if (this.gameState !== 'betting') {
                    console.log('Game already in progress, ignoring start request');
                    return;
                }
                
                clearInterval(this.timer);
                this.gameState = 'dealing';
                document.getElementById('dealBtn').disabled = true;
                
                try {
                    // Step 1: Request VRF randomness from Chainlink
                    const vrfResponse = await this.requestVRFRandomness();
                    
                    // Step 2: Create deck with VRF randomness
                    this.createVRFDeck(vrfResponse.randomNumbers);
                    
                    // Step 3: Start dealing with provably fair cards
                    document.getElementById('gameResult').textContent = 'üé¥ B·∫Øt ƒë·∫ßu chia b√†i v·ªõi VRF randomness...';
                    await this.sleep(1000);

                    // Deal initial cards
                    await this.dealInitialCards();
                    
                    // Check for natural wins
                    const playerScore = this.calculateScore(this.playerCards);
                    const bankerScore = this.calculateScore(this.bankerCards);
                    
                    console.log('Initial scores - Player:', playerScore, 'Banker:', bankerScore);
                    
                    if (playerScore >= 8 || bankerScore >= 8) {
                        console.log('Natural win detected');
                        await this.sleep(1000);
                        document.getElementById('gameResult').textContent = 'üéØ Natural! ƒêang t√≠nh to√°n k·∫øt qu·∫£...';
                        await this.sleep(1500);
                        this.finishGame();
                        return;
                    }

                    // Third card rules
                    await this.applyThirdCardRules();
                    
                    // Add dramatic pause before revealing results
                    await this.sleep(1000);
                    document.getElementById('gameResult').textContent = '‚ö° ƒêang t√≠nh to√°n k·∫øt qu·∫£ t·ª´ blockchain...';
                    await this.sleep(1500);
                    
                    this.finishGame();
                    
                } catch (error) {
                    console.error('VRF Error:', error);
                    document.getElementById('gameResult').textContent = '‚ùå L·ªói VRF, s·ª≠ d·ª•ng fallback randomness...';
                    
                    // Fallback to local randomness if VRF fails
                    this.createDeck();
                    this.shuffleDeck();
                    await this.dealInitialCards();
                    await this.applyThirdCardRules();
                    this.finishGame();
                }
            }

            async dealInitialCards() {
                // Deal 2 cards to player and banker alternately with realistic timing
                await this.dealCard('player');
                await this.sleep(800);
                await this.dealCard('banker');
                await this.sleep(800);
                await this.dealCard('player');
                await this.sleep(800);
                await this.dealCard('banker');
                await this.sleep(500);
            }

            async dealCard(to) {
                const card = this.deck.pop();
                if (to === 'player') {
                    this.playerCards.push(card);
                } else {
                    this.bankerCards.push(card);
                }
                
                await this.animateCardDeal(card, to);
                this.updateScores();
            }

            async animateCardDeal(card, to) {
                // Play card deal sound
                this.sounds.cardDeal?.();
                
                // Create dealing animation
                const dealerHand = document.getElementById('dealerHand');
                const dealingCard = document.createElement('div');
                dealingCard.className = 'dealing-card';
                dealingCard.innerHTML = 'üÇ†';
                dealerHand.appendChild(dealingCard);

                // Calculate target position
                const targetContainer = to === 'player' ? 
                    document.getElementById('playerCards') : 
                    document.getElementById('bankerCards');

                const dealerRect = dealerHand.getBoundingClientRect();
                const targetRect = targetContainer.getBoundingClientRect();
                
                const deltaX = targetRect.left - dealerRect.left + (targetContainer.children.length * 85);
                const deltaY = targetRect.top - dealerRect.top;

                // Animate the dealing
                dealingCard.style.opacity = '1';
                dealingCard.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.8s ease';
                
                await this.sleep(100);
                
                dealingCard.style.transform = `translateX(${deltaX}px) translateY(${deltaY}px) rotateZ(${Math.random() * 20 - 10}deg)`;
                
                await this.sleep(800);
                
                // Remove dealing card and create actual card
                dealerHand.removeChild(dealingCard);
                this.displayCard(card, to);
            }

            displayCard(card, to) {
                const cardElement = document.createElement('div');
                cardElement.className = `card ${card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'red' : ''}`;
                
                cardElement.innerHTML = `
                    <div class="card-inner">
                        <div class="card-back">
                            ‚ô†‚ô•‚ô¶‚ô£
                        </div>
                        <div class="card-front">
                            <div class="card-rank-top">${card.rank}</div>
                            <div class="card-suit-center">${card.suit}</div>
                            <div class="card-rank-bottom">${card.rank}</div>
                        </div>
                    </div>
                `;
                
                const container = to === 'player' ? 
                    document.getElementById('playerCards') : 
                    document.getElementById('bankerCards');
                
                container.appendChild(cardElement);
                
                // Start with card face down, then flip after short delay (fixed order)
                setTimeout(() => {
                    cardElement.classList.add('flipped');
                    this.sounds.cardFlip?.(); // Play flip sound
                }, 200);

                // Add hover effect for better interaction
                cardElement.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-10px) rotateX(15deg) rotateY(5deg)';
                });
                
                cardElement.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0) rotateX(0deg) rotateY(0deg)';
                });
            }

            async applyThirdCardRules() {
                const playerScore = this.calculateScore(this.playerCards);
                const bankerScore = this.calculateScore(this.bankerCards);
                
                let playerThirdCard = null;
                
                // Player third card rule
                if (playerScore <= 5) {
                    await this.sleep(1000);
                    await this.dealCard('player');
                    playerThirdCard = this.playerCards[2];
                }
                
                // Banker third card rules
                const newPlayerScore = this.calculateScore(this.playerCards);
                let bankerShouldDraw = false;
                
                if (this.bankerCards.length === 2) { // Banker hasn't drawn yet
                    if (playerThirdCard === null) {
                        // Player didn't draw, banker draws if score <= 5
                        bankerShouldDraw = bankerScore <= 5;
                    } else {
                        // Player drew third card, complex banker rules
                        const thirdCardValue = playerThirdCard.value;
                        
                        if (bankerScore <= 2) bankerShouldDraw = true;
                        else if (bankerScore === 3) bankerShouldDraw = thirdCardValue !== 8;
                        else if (bankerScore === 4) bankerShouldDraw = [2,3,4,5,6,7].includes(thirdCardValue);
                        else if (bankerScore === 5) bankerShouldDraw = [4,5,6,7].includes(thirdCardValue);
                        else if (bankerScore === 6) bankerShouldDraw = [6,7].includes(thirdCardValue);
                    }
                    
                    if (bankerShouldDraw) {
                        await this.sleep(1000);
                        await this.dealCard('banker');
                    }
                }
            }

            finishGame() {
                this.gameState = 'finished';
                
                const playerScore = this.calculateScore(this.playerCards);
                const bankerScore = this.calculateScore(this.bankerCards);
                
                let winner;
                if (playerScore > bankerScore) {
                    winner = 'player';
                    this.stats.playerWins++;
                    document.getElementById('gameResult').textContent = 'üé≠ PLAYER TH·∫ÆNG! (VRF Verified)';
                    document.getElementById('gameResult').className = 'result-display winner';
                } else if (bankerScore > playerScore) {
                    winner = 'banker';
                    this.stats.bankerWins++;
                    document.getElementById('gameResult').textContent = 'üè¶ BANKER TH·∫ÆNG! (VRF Verified)';
                    document.getElementById('gameResult').className = 'result-display winner';
                } else {
                    winner = 'tie';
                    this.stats.ties++;
                    document.getElementById('gameResult').textContent = 'ü§ù H√íA! (VRF Verified)';
                    document.getElementById('gameResult').className = 'result-display tie';
                }
                
                // Log game result
                this.addConsoleLog(`üèÅ Game finished! Winner: ${winner.toUpperCase()}`, 'success');
                this.addConsoleLog(`üìä Final scores - Player: ${playerScore}, Banker: ${bankerScore}`, 'info');
                
                if (this.vrfRequestId) {
                    this.addConsoleLog(`üîê Result verified by VRF: ${this.vrfRequestId}`, 'success');
                }
                
                // Check player's personal bets and show personalized message
                this.showPersonalizedMessage(winner);
                
                // Play win sound and create celebration effects
                this.sounds.win?.();
                this.createWinEffects(winner);
                this.addWinnerGlow(winner);
                
                this.stats.totalGames++;
                this.updateStats();
                this.calculatePayouts(winner);
                
                // Auto reset after 8 seconds (longer to read message)
                setTimeout(() => {
                    this.resetGame();
                }, 8000);
            }

            showPersonalizedMessage(winner) {
                const playerBetAmount = this.currentGameBets[winner] || 0;
                const playerLostBets = Object.keys(this.currentGameBets)
                    .filter(bet => bet !== winner)
                    .reduce((sum, bet) => sum + this.currentGameBets[bet], 0);
                
                let message, emoji, messageClass, amount;
                
                if (playerBetAmount > 0) {
                    // Player won
                    const winnings = winner === 'tie' ? playerBetAmount * 8 : playerBetAmount * 2;
                    const profit = winnings - (playerBetAmount + playerLostBets);
                    
                    this.addConsoleLog(`üéâ Player WON! Bet: ${playerBetAmount} ETH on ${winner.toUpperCase()}`, 'success');
                    this.addConsoleLog(`üí∞ Total winnings: ${winnings} ETH (${profit > 0 ? '+' : ''}${profit} ETH profit)`, 'success');
                    
                    emoji = profit > 0 ? 'üéâ' : 'üòä';
                    message = profit > 0 ? 
                        `Ch√∫c m·ª´ng! B·∫°n ƒë√£ th·∫Øng!<br/>L·ª£i nhu·∫≠n: ${profit.toFixed(2)} ETH` :
                        `B·∫°n ƒë√£ th·∫Øng c∆∞·ª£c!<br/>Ho√† v·ªën th·∫≠t tuy·ªát!`;
                    amount = `Ti·ªÅn th·∫Øng: ${winnings.toFixed(2)} ETH`;
                    messageClass = 'win';
                    
                } else if (playerLostBets > 0) {
                    // Player lost
                    this.addConsoleLog(`üò¢ Player lost ${playerLostBets} ETH this round`, 'warning');
                    
                    const encouragements = [
                        'ƒê·ª´ng n·∫£n ch√≠! V√°n sau s·∫Ω may m·∫Øn h∆°n!',
                        'C∆° h·ªôi lu√¥n c√≥! H√£y th·ª≠ l·∫°i nh√©!',
                        'Ki√™n nh·∫´n l√† ch√¨a kh√≥a th√†nh c√¥ng!',
                        'M·ªói v√°n ch∆°i l√† m·ªôt c∆° h·ªôi m·ªõi!',
                        'V·∫≠n may s·∫Ω quay l·∫°i v·ªõi b·∫°n!'
                    ];
                    
                    emoji = 'üí™';
                    message = encouragements[Math.floor(Math.random() * encouragements.length)];
                    amount = `Ti·∫øp t·ª•c c·ªë g·∫Øng!`;
                    messageClass = 'lose';
                    
                } else {
                    // Player didn't bet this round
                    this.addConsoleLog('üëÄ Player observed this round without betting', 'info');
                    
                    emoji = 'üëÄ';
                    message = 'Quan s√°t k·ªπ ƒë·ªÉ c∆° h·ªôi ti·∫øp theo!<br/>H√£y ƒë·∫∑t c∆∞·ª£c v√°n sau nh√©!';
                    amount = 'Ch·ªù c∆° h·ªôi t·ªët';
                    messageClass = 'info';
                }
                
                this.displayPersonalMessage(emoji, message, amount, messageClass);
            }

            displayPersonalMessage(emoji, message, amount, messageClass) {
                const messageElement = document.getElementById('personalMessage');
                const emojiElement = document.getElementById('messageEmoji');
                const textElement = document.getElementById('messageText');
                const amountElement = document.getElementById('messageAmount');
                
                emojiElement.textContent = emoji;
                textElement.innerHTML = message;
                amountElement.textContent = amount;
                
                messageElement.className = `personal-message ${messageClass}`;
                messageElement.classList.add('show');
                
                // Hide after 5 seconds
                setTimeout(() => {
                    messageElement.classList.remove('show');
                }, 5000);
            }

            createWinEffects(winner) {
                // Create confetti for big wins
                if (winner !== 'tie') {
                    this.createConfetti();
                }
                
                // Create particle explosion at result display
                const resultDisplay = document.getElementById('gameResult');
                const rect = resultDisplay.getBoundingClientRect();
                
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = `particle ${winner === 'player' ? 'gold' : winner === 'banker' ? 'silver' : 'red'}`;
                        particle.style.position = 'fixed';
                        particle.style.left = (rect.left + rect.width/2 + (Math.random() - 0.5) * 100) + 'px';
                        particle.style.top = (rect.top + rect.height/2) + 'px';
                        particle.style.width = (8 + Math.random() * 8) + 'px';
                        particle.style.height = particle.style.width;
                        particle.style.zIndex = '1000';
                        
                        document.body.appendChild(particle);
                        
                        setTimeout(() => {
                            if (document.body.contains(particle)) {
                                document.body.removeChild(particle);
                            }
                        }, 2000);
                    }, i * 50);
                }
            }

            createConfetti() {
                const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'];
                
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const confetti = document.createElement('div');
                        confetti.className = 'confetti';
                        confetti.style.position = 'fixed';
                        confetti.style.left = Math.random() * window.innerWidth + 'px';
                        confetti.style.top = '-10px';
                        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                        confetti.style.width = (5 + Math.random() * 10) + 'px';
                        confetti.style.height = confetti.style.width;
                        confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                        confetti.style.animation = `confetti-fall ${2 + Math.random() * 3}s linear forwards`;
                        confetti.style.zIndex = '999';
                        
                        document.body.appendChild(confetti);
                        
                        setTimeout(() => {
                            if (document.body.contains(confetti)) {
                                document.body.removeChild(confetti);
                            }
                        }, 5000);
                    }, i * 100);
                }
            }

            addWinnerGlow(winner) {
                const winnerArea = winner === 'player' ? 
                    document.querySelector('[data-bet="player"]') :
                    winner === 'banker' ? 
                    document.querySelector('[data-bet="banker"]') :
                    document.querySelector('[data-bet="tie"]');
                
                if (winnerArea) {
                    winnerArea.classList.add('winner-glow');
                    setTimeout(() => {
                        winnerArea.classList.remove('winner-glow');
                    }, 3000);
                }
            }

            calculatePayouts(winner) {
                const totalPool = Object.values(this.bets).reduce((sum, bet) => sum + bet, 0);
                const houseRake = totalPool * 0.03; // 3% DAO fee
                const payoutPool = totalPool - houseRake;
                
                console.log(`Winner: ${winner}`);
                console.log(`Total Pool: ${totalPool} ETH`);
                console.log(`House Rake: ${houseRake} ETH`);
                console.log(`Payout Pool: ${payoutPool} ETH`);
                
                // In real implementation, this would distribute to winners
            }

            updateScores() {
                document.getElementById('playerScore').textContent = this.calculateScore(this.playerCards);
                document.getElementById('bankerScore').textContent = this.calculateScore(this.bankerCards);
            }

            updateDisplay() {
                const playerBetElement = document.getElementById('playerBet');
                const bankerBetElement = document.getElementById('bankerBet');
                const tieBetElement = document.getElementById('tieBet');
                
                if (playerBetElement) playerBetElement.textContent = this.bets.player + ' ETH';
                if (bankerBetElement) bankerBetElement.textContent = this.bets.banker + ' ETH';
                if (tieBetElement) tieBetElement.textContent = this.bets.tie + ' ETH';
                
                const totalPool = Object.values(this.bets).reduce((sum, bet) => sum + bet, 0);
                
                const totalPoolElement = document.getElementById('totalPool');
                const playersCountElement = document.getElementById('playersCount');
                
                if (totalPoolElement) totalPoolElement.textContent = totalPool + ' ETH';
                if (playersCountElement) playersCountElement.textContent = this.playersCount;
                
                console.log('Display updated:', {
                    playerBet: this.bets.player,
                    bankerBet: this.bets.banker,
                    tieBet: this.bets.tie,
                    totalPool: totalPool,
                    playersCount: this.playersCount
                });
            }

            updateStats() {
                document.getElementById('playerWins').textContent = this.stats.playerWins;
                document.getElementById('bankerWins').textContent = this.stats.bankerWins;
                document.getElementById('ties').textContent = this.stats.ties;
                document.getElementById('totalGames').textContent = this.stats.totalGames;
            }

            resetGame() {
                clearInterval(this.timer);
                this.gameState = 'betting';
                this.playerCards = [];
                this.bankerCards = [];
                this.bets = { player: 0, banker: 0, tie: 0 };
                this.selectedBet = null;
                this.playersCount = 0;
                this.timeLeft = 30;
                
                document.getElementById('playerCards').innerHTML = '';
                document.getElementById('bankerCards').innerHTML = '';
                document.getElementById('playerScore').textContent = '0';
                document.getElementById('bankerScore').textContent = '0';
                document.getElementById('gameResult').textContent = 'Ch·ªù ng∆∞·ªùi ch∆°i ƒë·∫∑t c∆∞·ª£c...';
                document.getElementById('gameResult').className = 'result-display';
                document.getElementById('dealBtn').disabled = true;
                
                document.querySelectorAll('.bet-area').forEach(area => {
                    area.classList.remove('selected');
                });
                
                this.createDeck();
                this.shuffleDeck();
                this.updateDisplay();
                this.startBettingTimer();
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            const game = new BaccaratGame();
            
            // Enable audio on first user interaction
            document.addEventListener('click', function enableAudio() {
                if (game.audioContext && game.audioContext.state === 'suspended') {
                    game.audioContext.resume();
                }
                document.removeEventListener('click', enableAudio);
            });
        });
    </script>
</body>
</html>