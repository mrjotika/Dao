<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baccarat P2P - Blockchain Gaming</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #0f1419 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #ffd700, #ff6b35);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .game-table {
            background: radial-gradient(ellipse at center, #0d4f2c 0%, #1a3d29 50%, #0a2818 100%);
            border-radius: 200px 200px 50px 50px;
            padding: 40px;
            margin: 30px auto;
            max-width: 900px;
            border: 8px solid #ffd700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
            position: relative;
        }

        .betting-areas {
            display: flex;
            justify-content: space-around;
            margin-bottom: 40px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .bet-area {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
            position: relative;
            overflow: hidden;
        }

        .bet-area:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
        }

        .bet-area.selected {
            background: linear-gradient(135deg, #ff6b35 0%, #ffd700 100%);
            color: #000;
        }

        .bet-area h3 {
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .bet-amount {
            font-size: 1.1em;
            font-weight: bold;
        }

        .cards-area {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 40px 0;
            flex-wrap: wrap;
            gap: 30px;
        }

        .player-cards, .banker-cards {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .card-section h3 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #ffd700;
        }

        .cards {
            display: flex;
            gap: 10px;
        }

        .card {
            width: 80px;
            height: 120px;
            position: relative;
            margin: 5px;
            perspective: 1000px;
            transform-style: preserve-3d;
            transition: transform 0.6s ease;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s ease;
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 12px;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 8px;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            border: 1px solid rgba(0,0,0,0.1);
        }

        .card-front {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
            color: #333;
            border: 2px solid #ddd;
            transform: rotateY(180deg);
        }

        .card-back {
            background: linear-gradient(145deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: 2px solid #ffd700;
        }

        .card-back::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
        }

        .card-back::after {
            content: '♠♥♦♣';
            font-size: 12px;
            letter-spacing: 2px;
            opacity: 0.3;
        }

        .card.red .card-front {
            color: #d63031;
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card:hover {
            transform: translateY(-5px) rotateX(5deg);
        }

        .card-rank-top {
            font-size: 18px;
            line-height: 1;
        }

        .card-suit-center {
            font-size: 32px;
            text-align: center;
            margin: 10px 0;
        }

        .card-rank-bottom {
            font-size: 18px;
            line-height: 1;
            transform: rotate(180deg);
            text-align: right;
        }

        .deck-area {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px;
            height: 120px;
        }

        .deck-card {
            position: absolute;
            width: 80px;
            height: 120px;
            background: linear-gradient(145deg, #1e3c72 0%, #2a5298 100%);
            border: 2px solid #ffd700;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .deck-card:nth-child(1) { transform: translateY(0px) translateX(0px); }
        .deck-card:nth-child(2) { transform: translateY(-2px) translateX(-1px); }
        .deck-card:nth-child(3) { transform: translateY(-4px) translateX(-2px); }
        .deck-card:nth-child(4) { transform: translateY(-6px) translateX(-3px); }
        .deck-card:nth-child(5) { transform: translateY(-8px) translateX(-4px); }

        .score {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
            margin-top: 10px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);
            color: white;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info-card h4 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .betting-input {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .betting-input input {
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 16px;
            width: 150px;
        }

        .betting-input input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .quick-bet-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .quick-bet {
            padding: 8px 15px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 20px;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quick-bet:hover {
            background: rgba(255, 215, 0, 0.4);
        }

        .result-display {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            border-radius: 15px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-display.winner {
            background: linear-gradient(135deg, #00b894, #00cec9);
            color: white;
        }

        .result-display.loser {
            background: linear-gradient(135deg, #d63031, #e17055);
            color: white;
        }

        .result-display.tie {
            background: linear-gradient(135deg, #fdcb6e, #e17055);
            color: white;
        }

        @keyframes dealFromDeck {
            0% {
                transform: translateX(0) translateY(0) rotateY(0deg) scale(0.8);
                opacity: 1;
            }
            30% {
                transform: translateX(-100px) translateY(-50px) rotateY(90deg) scale(0.9);
                opacity: 0.8;
            }
            70% {
                transform: translateX(-200px) translateY(-20px) rotateY(170deg) scale(1);
                opacity: 0.9;
            }
            100% {
                transform: translateX(-300px) translateY(0) rotateY(180deg) scale(1);
                opacity: 1;
            }
        }

        @keyframes flipCard {
            0% {
                transform: rotateY(180deg);
            }
            100% {
                transform: rotateY(0deg);
            }
        }

        .card.dealing {
            animation: dealFromDeck 1s ease-out;
        }

        .card.flipping {
            animation: flipCard 0.6s ease-out 1s forwards;
        }

        .dealer-hand {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 150px;
            pointer-events: none;
            z-index: 100;
        }

        .dealing-card {
            position: absolute;
            width: 80px;
            height: 120px;
            background: linear-gradient(145deg, #1e3c72 0%, #2a5298 100%);
            border: 2px solid #ffd700;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffd700;
            font-size: 24px;
            opacity: 0;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
            gap: 20px;
        }

        .stat-item {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            min-width: 100px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }

        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: particle-float 2s ease-out forwards;
        }

        .particle.gold {
            background: radial-gradient(circle, #ffd700 0%, #ffed4e 100%);
            box-shadow: 0 0 10px #ffd700;
        }

        .particle.silver {
            background: radial-gradient(circle, #c0c0c0 0%, #e8e8e8 100%);
            box-shadow: 0 0 8px #c0c0c0;
        }

        .particle.red {
            background: radial-gradient(circle, #ff6b6b 0%, #ff5252 100%);
            box-shadow: 0 0 8px #ff6b6b;
        }

        @keyframes particle-float {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translateY(-100px) scale(0.8);
                opacity: 0.7;
            }
            100% {
                transform: translateY(-200px) scale(0.3);
                opacity: 0;
            }
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd700;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .winner-glow {
            animation: winner-pulse 2s ease-in-out infinite;
        }

        @keyframes winner-pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.4);
            }
        }

        .dealing-sound-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .dealing-sound-indicator.active {
            opacity: 1;
            animation: sound-pulse 0.5s ease-out;
        }

        @keyframes sound-pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3);
            }
            100% {
                transform: scale(1);
            }
        }

        .countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .countdown-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .countdown-number {
            font-size: 8rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            animation: countdown-pulse 1s ease-in-out;
        }

        @keyframes countdown-pulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
            .container {
                padding: 10px;
            }
            
            .game-table {
                padding: 20px;
            }
            
            .cards-area {
                flex-direction: column;
                gap: 20px;
            }
            
            .betting-areas {
                flex-direction: column;
                align-items: center;
            }
            
            .bet-area {
                min-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎰 BACCARAT P2P 🎰</h1>
            <p>Blockchain • DAO • Peer-to-Peer Betting</p>
        </div>

        <div class="game-info">
            <div class="info-card">
                <h4>💰 Tổng Pool</h4>
                <div id="totalPool">0 ETH</div>
            </div>
            <div class="info-card">
                <h4>👥 Người chơi</h4>
                <div id="playersCount">0</div>
            </div>
            <div class="info-card">
                <h4>⏱️ Thời gian còn lại</h4>
                <div id="timeLeft">30s</div>
            </div>
            <div class="info-card">
                <h4>🏠 DAO Fee</h4>
                <div>3%</div>
            </div>
        </div>

        <div class="game-table">
            <div class="betting-areas">
                <div class="bet-area" data-bet="player">
                    <h3>🎭 PLAYER</h3>
                    <div class="bet-amount" id="playerBet">0 ETH</div>
                    <div style="font-size: 0.9em; margin-top: 5px;">Tỷ lệ: 1:1</div>
                </div>
                <div class="bet-area" data-bet="tie">
                    <h3>🤝 TIE</h3>
                    <div class="bet-amount" id="tieBet">0 ETH</div>
                    <div style="font-size: 0.9em; margin-top: 5px;">Tỷ lệ: 8:1</div>
                </div>
                <div class="bet-area" data-bet="banker">
                    <h3>🏦 BANKER</h3>
                    <div class="bet-amount" id="bankerBet">0 ETH</div>
                    <div style="font-size: 0.9em; margin-top: 5px;">Tỷ lệ: 1:1</div>
                </div>
            </div>

            <div class="betting-input">
                <input type="number" id="betAmount" placeholder="Số ETH đặt cược" min="0.01" step="0.01">
            </div>

            <div class="quick-bet-buttons">
                <div class="quick-bet" data-amount="0.1">0.1 ETH</div>
                <div class="quick-bet" data-amount="0.5">0.5 ETH</div>
                <div class="quick-bet" data-amount="1">1 ETH</div>
                <div class="quick-bet" data-amount="5">5 ETH</div>
            </div>

            <div class="cards-area">
                <div class="deck-area">
                    <div class="deck-card"></div>
                    <div class="deck-card"></div>
                    <div class="deck-card"></div>
                    <div class="deck-card"></div>
                    <div class="deck-card"></div>
                </div>

                <div class="dealer-hand" id="dealerHand"></div>

                <div class="player-cards card-section">
                    <h3>🎭 PLAYER</h3>
                    <div class="cards" id="playerCards"></div>
                    <div class="score" id="playerScore">0</div>
                </div>

                <div class="banker-cards card-section">
                    <h3>🏦 BANKER</h3>
                    <div class="cards" id="bankerCards"></div>
                    <div class="score" id="bankerScore">0</div>
                </div>
            </div>

            <div class="result-display" id="gameResult">
                Chờ người chơi đặt cược...
            </div>

            <div class="controls">
                <button class="btn btn-primary" id="dealBtn" disabled>🎯 BẮT ĐẦU GAME</button>
                <button class="btn btn-secondary" id="resetBtn">🔄 RESET</button>
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="playerWins">0</div>
                <div class="stat-label">Player Wins</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="bankerWins">0</div>
                <div class="stat-label">Banker Wins</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="ties">0</div>
                <div class="stat-label">Ties</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalGames">0</div>
                <div class="stat-label">Total Games</div>
            </div>
        </div>
    </div>

    <!-- Countdown Overlay -->
    <div class="countdown-overlay" id="countdownOverlay">
        <div class="countdown-number" id="countdownNumber"></div>
    </div>

    <!-- Personal Message Popup -->
    <div class="personal-message" id="personalMessage">
        <span class="emoji" id="messageEmoji"></span>
        <div id="messageText"></div>
        <div class="amount" id="messageAmount"></div>
    </div>

    <!-- Console Log Display -->
    <button class="console-toggle" onclick="toggleConsole()">🖥️ Console</button>
    <div class="console-log" id="consoleLog">
        <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">🎰 BACCARAT BLOCKCHAIN CONSOLE 🎰</div>
    </div>

    <!-- Sound Indicator -->
    <div class="dealing-sound-indicator" id="soundIndicator">🔊</div>

    <script>
        class BaccaratGame {
            constructor() {
                this.deck = [];
                this.playerCards = [];
                this.bankerCards = [];
                this.bets = {
                    player: 0,
                    banker: 0,
                    tie: 0
                };
                this.selectedBet = null;
                this.gameState = 'betting';
                this.stats = {
                    playerWins: 0,
                    bankerWins: 0,
                    ties: 0,
                    totalGames: 0
                };
                this.timeLeft = 30;
                this.timer = null;
                this.playersCount = 0;
                this.audioContext = null;
                this.sounds = {};
                
                // Player tracking for personalized messages
                this.playerBets = {};
                this.currentGameBets = {};
                
                // Chainlink VRF simulation
                this.vrfRequestId = null;
                this.pendingVRF = false;
                this.vrfResults = [];
                
                this.initializeAudio();
                this.initializeGame();
                this.bindEvents();
                this.startBettingTimer();
                this.initializeConsole();
            }

            initializeConsole() {
                this.consoleLines = [];
                this.addConsoleLog('🚀 Baccarat P2P Game Initialized', 'success');
                this.addConsoleLog('⛓️ Connected to Arbitrum Layer 2', 'info');
                this.addConsoleLog('🔗 Chainlink VRF Oracle Ready', 'info');
            }

            addConsoleLog(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logLine = `[${timestamp}] ${message}`;
                
                this.consoleLines.push({ text: logLine, type: type });
                
                // Keep only last 50 lines
                if (this.consoleLines.length > 50) {
                    this.consoleLines.shift();
                }
                
                this.updateConsoleDisplay();
                
                // Also log to browser console for development
                console.log(logLine);
            }

            updateConsoleDisplay() {
                const consoleElement = document.getElementById('consoleLog');
                const logsHtml = this.consoleLines.map(line => 
                    `<div class="log-line ${line.type}">${line.text}</div>`
                ).join('');
                
                consoleElement.innerHTML = `
                    <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">🎰 BACCARAT BLOCKCHAIN CONSOLE 🎰</div>
                    ${logsHtml}
                `;
                
                // Auto scroll to bottom
                consoleElement.scrollTop = consoleElement.scrollHeight;
            }

            // Simulate Chainlink VRF request for true randomness
            async requestVRFRandomness() {
                this.pendingVRF = true;
                this.vrfRequestId = 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                this.addConsoleLog('🔗 Requesting Chainlink VRF randomness...', 'info');
                this.addConsoleLog(`📋 Request ID: ${this.vrfRequestId}`, 'info');
                document.getElementById('gameResult').textContent = '🔗 Đang yêu cầu random từ Chainlink VRF...';
                
                // Simulate network delay for VRF
                await this.sleep(2000);
                
                // Simulate VRF response with cryptographically secure randomness
                const vrfResponse = await this.simulateChainlinkVRF();
                
                this.addConsoleLog('✅ VRF Response received from Oracle', 'success');
                this.addConsoleLog(`🔐 Block Hash: ${vrfResponse.blockHash.substr(0, 20)}...`, 'info');
                this.addConsoleLog(`⚡ Gas Used: ${vrfResponse.gasUsed}`, 'info');
                
                document.getElementById('gameResult').textContent = '✅ Nhận được kết quả random từ blockchain!';
                
                this.vrfResults = vrfResponse.randomNumbers;
                this.pendingVRF = false;
                
                return vrfResponse;
            }

            async simulateChainlinkVRF() {
                // Simulate real Chainlink VRF response structure
                const blockHash = '0x' + Array.from({length: 64}, () => Math.floor(Math.random() * 16).toString(16)).join('');
                const vrfProof = '0x' + Array.from({length: 128}, () => Math.floor(Math.random() * 16).toString(16)).join('');
                
                // Generate 10 random numbers for card dealing (more than needed for safety)
                const randomNumbers = [];
                for (let i = 0; i < 10; i++) {
                    // Simulate Chainlink VRF big random number
                    const bigRandomHex = Array.from({length: 64}, () => Math.floor(Math.random() * 16).toString(16)).join('');
                    const randomValue = parseInt(bigRandomHex.substr(0, 8), 16);
                    randomNumbers.push(randomValue);
                }
                
                return {
                    requestId: this.vrfRequestId,
                    blockHash: blockHash,
                    vrfProof: vrfProof,
                    randomNumbers: randomNumbers,
                    gasUsed: '150000',
                    timestamp: Date.now()
                };
            }

            // Create verifiably random deck using VRF results
            createVRFDeck(vrfRandomNumbers) {
                console.log('🎴 Creating VRF-shuffled deck...');
                
                const suits = ['♠', '♥', '♦', '♣'];
                const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                
                this.deck = [];
                for (let suit of suits) {
                    for (let rank of ranks) {
                        this.deck.push({
                            suit: suit,
                            rank: rank,
                            value: this.getCardValue(rank)
                        });
                    }
                }

                // Shuffle using VRF randomness (Fisher-Yates with VRF)
                let vrfIndex = 0;
                for (let i = this.deck.length - 1; i > 0; i--) {
                    // Use VRF random number instead of Math.random()
                    const vrfRandom = vrfRandomNumbers[vrfIndex % vrfRandomNumbers.length];
                    const j = vrfRandom % (i + 1);
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                    vrfIndex++;
                }
                
                console.log('✅ Deck shuffled with VRF randomness. First 5 cards:', 
                    this.deck.slice(0, 5).map(c => c.rank + c.suit));
            }

            async initializeAudio() {
                try {
                    // Initialize Web Audio API for sound effects
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create sound effects using Web Audio API
                    this.sounds = {
                        cardDeal: this.createCardDealSound(),
                        cardFlip: this.createCardFlipSound(),
                        win: this.createWinSound(),
                        countdown: this.createCountdownSound(),
                        bet: this.createBetSound()
                    };
                } catch (error) {
                    console.log('Audio not supported, using visual indicators only');
                }
            }

            createCardDealSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                    
                    this.showSoundIndicator();
                };
            }

            createCardFlipSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.05);
                    
                    gainNode.gain.setValueAtTime(0.05, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.05);
                };
            }

            createWinSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const frequencies = [523, 659, 784, 1047]; // C, E, G, C
                    frequencies.forEach((freq, index) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime + index * 0.1);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime + index * 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + index * 0.1 + 0.3);
                        
                        oscillator.start(this.audioContext.currentTime + index * 0.1);
                        oscillator.stop(this.audioContext.currentTime + index * 0.1 + 0.3);
                    });
                };
            }

            createCountdownSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.2);
                };
            }

            createBetSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.05, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
            }

            showSoundIndicator() {
                const indicator = document.getElementById('soundIndicator');
                indicator.classList.add('active');
                setTimeout(() => {
                    indicator.classList.remove('active');
                }, 500);
            }

            initializeGame() {
                this.createDeck();
                this.shuffleDeck();
                this.updateDisplay();
            }

            createDeck() {
                const suits = ['♠', '♥', '♦', '♣'];
                const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                
                this.deck = [];
                for (let suit of suits) {
                    for (let rank of ranks) {
                        this.deck.push({
                            suit: suit,
                            rank: rank,
                            value: this.getCardValue(rank)
                        });
                    }
                }
            }

            shuffleDeck() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            getCardValue(rank) {
                if (rank === 'A') return 1;
                if (['J', 'Q', 'K'].includes(rank)) return 0;
                return parseInt(rank);
            }

            calculateScore(cards) {
                return cards.reduce((sum, card) => sum + card.value, 0) % 10;
            }

            bindEvents() {
                // Betting area selection
                document.querySelectorAll('.bet-area').forEach(area => {
                    area.addEventListener('click', (e) => {
                        if (this.gameState !== 'betting') return;
                        
                        console.log('Bet area clicked:', area.dataset.bet);
                        
                        document.querySelectorAll('.bet-area').forEach(a => a.classList.remove('selected'));
                        area.classList.add('selected');
                        this.selectedBet = area.dataset.bet;
                        
                        console.log('Selected bet set to:', this.selectedBet);
                    });
                });

                // Quick bet buttons
                document.querySelectorAll('.quick-bet').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        console.log('Quick bet clicked:', btn.dataset.amount);
                        const amount = btn.dataset.amount;
                        document.getElementById('betAmount').value = amount;
                        
                        // Auto place bet if bet type is selected
                        if (this.selectedBet) {
                            console.log('Auto placing bet after quick bet selection');
                            this.placeBet();
                        }
                    });
                });

                // Place bet when amount is entered and bet type selected
                document.getElementById('betAmount').addEventListener('input', (e) => {
                    console.log('Bet amount input changed:', e.target.value);
                    // Remove auto-place on input to avoid accidental bets
                });

                document.getElementById('betAmount').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        console.log('Enter pressed, attempting to place bet');
                        if (this.selectedBet) {
                            this.placeBet();
                        } else {
                            console.log('No bet type selected!');
                            alert('Vui lòng chọn Player, Banker hoặc Tie trước!');
                        }
                    }
                });

                // Deal button
                document.getElementById('dealBtn').addEventListener('click', () => {
                    console.log('Deal button clicked');
                    this.startGame();
                });

                // Reset button
                document.getElementById('resetBtn').addEventListener('click', () => {
                    console.log('Reset button clicked');
                    this.resetGame();
                });
            }

            checkCanPlaceBet() {
                const amount = parseFloat(document.getElementById('betAmount').value);
                if (amount > 0 && this.selectedBet && this.gameState === 'betting') {
                    console.log('Auto placing bet:', amount, 'on', this.selectedBet);
                    this.placeBet();
                }
            }

            placeBet() {
                const amount = parseFloat(document.getElementById('betAmount').value);
                
                this.addConsoleLog(`🎯 Attempting to place bet: ${amount} ETH on ${this.selectedBet}`, 'info');
                
                if (amount > 0 && this.selectedBet && this.gameState === 'betting') {
                    this.bets[this.selectedBet] += amount;
                    this.playersCount++;
                    
                    // Track individual player bet
                    this.currentGameBets[this.selectedBet] = (this.currentGameBets[this.selectedBet] || 0) + amount;
                    
                    document.getElementById('betAmount').value = '';
                    
                    this.addConsoleLog(`✅ Bet placed successfully! ${amount} ETH on ${this.selectedBet.toUpperCase()}`, 'success');
                    this.addConsoleLog(`💰 Total pool: ${Object.values(this.bets).reduce((sum, bet) => sum + bet, 0)} ETH`, 'info');
                    
                    this.updateDisplay();
                    
                    // Play bet sound and create particles
                    this.sounds.bet?.();
                    this.createBetParticles();
                    
                    // Enable deal button if there are bets
                    const totalBets = Object.values(this.bets).reduce((sum, bet) => sum + bet, 0);
                    document.getElementById('dealBtn').disabled = totalBets === 0;
                    
                } else {
                    this.addConsoleLog(`❌ Cannot place bet - Invalid conditions`, 'error');
                    this.addConsoleLog(`   Amount: ${amount}, Selected: ${this.selectedBet}, State: ${this.gameState}`, 'warning');
                }
            }

            createBetParticles() {
                const betArea = document.querySelector('.bet-area.selected');
                if (!betArea) return;
                
                const rect = betArea.getBoundingClientRect();
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = 'particle gold';
                        particle.style.position = 'fixed';
                        particle.style.left = (rect.left + rect.width/2) + 'px';
                        particle.style.top = (rect.top + rect.height/2) + 'px';
                        particle.style.width = '8px';
                        particle.style.height = '8px';
                        particle.style.zIndex = '1000';
                        
                        // Random direction
                        const angle = (Math.PI * 2 * i) / 6;
                        const distance = 50 + Math.random() * 30;
                        particle.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
                        
                        document.body.appendChild(particle);
                        
                        setTimeout(() => {
                            document.body.removeChild(particle);
                        }, 2000);
                    }, i * 50);
                }
            }

            startBettingTimer() {
                this.timer = setInterval(() => {
                    this.timeLeft--;
                    document.getElementById('timeLeft').textContent = this.timeLeft + 's';
                    
                    // Warning countdown sounds and effects
                    if (this.timeLeft <= 5 && this.timeLeft > 0) {
                        this.sounds.countdown?.();
                        this.showCountdownOverlay(this.timeLeft);
                    }
                    
                    if (this.timeLeft <= 0) {
                        clearInterval(this.timer); // Stop timer immediately
                        this.timeLeft = 0;
                        
                        const totalBets = Object.values(this.bets).reduce((sum, bet) => sum + bet, 0);
                        console.log('Time up! Total bets:', totalBets); // Debug log
                        
                        if (totalBets > 0) {
                            this.showCountdownOverlay('GO!');
                            setTimeout(() => {
                                this.hideCountdownOverlay();
                                this.startGame();
                            }, 1000);
                        } else {
                            // If no bets, add some demo bets and start game anyway
                            console.log('No bets found, adding demo bets...');
                            this.bets.player = 1;
                            this.bets.banker = 1;
                            this.playersCount = 2;
                            this.updateDisplay();
                            
                            this.showCountdownOverlay('GO!');
                            setTimeout(() => {
                                this.hideCountdownOverlay();
                                this.startGame();
                            }, 1000);
                        }
                    }
                }, 1000);
            }

            showCountdownOverlay(text) {
                const overlay = document.getElementById('countdownOverlay');
                const number = document.getElementById('countdownNumber');
                number.textContent = text;
                overlay.classList.add('active');
                
                setTimeout(() => {
                    overlay.classList.remove('active');
                }, 800);
            }

            hideCountdownOverlay() {
                const overlay = document.getElementById('countdownOverlay');
                overlay.classList.remove('active');
            }

            resetTimer() {
                clearInterval(this.timer);
                this.timeLeft = 30;
                document.getElementById('timeLeft').textContent = this.timeLeft + 's';
                this.startBettingTimer();
            }

            async startGame() {
                console.log('Starting game... Current state:', this.gameState);
                
                if (this.gameState !== 'betting') {
                    console.log('Game already in progress, ignoring start request');
                    return;
                }
                
                clearInterval(this.timer);
                this.gameState = 'dealing';
                document.getElementById('dealBtn').disabled = true;
                
                try {
                    // Step 1: Request VRF randomness from Chainlink
                    const vrfResponse = await this.requestVRFRandomness();
                    
                    // Step 2: Create deck with VRF randomness
                    this.createVRFDeck(vrfResponse.randomNumbers);
                    
                    // Step 3: Start dealing with provably fair cards
                    document.getElementById('gameResult').textContent = '🎴 Bắt đầu chia bài với VRF randomness...';
                    await this.sleep(1000);

                    // Deal initial cards
                    await this.dealInitialCards();
                    
                    // Check for natural wins
                    const playerScore = this.calculateScore(this.playerCards);
                    const bankerScore = this.calculateScore(this.bankerCards);
                    
                    console.log('Initial scores - Player:', playerScore, 'Banker:', bankerScore);
                    
                    if (playerScore >= 8 || bankerScore >= 8) {
                        console.log('Natural win detected');
                        await this.sleep(1000);
                        document.getElementById('gameResult').textContent = '🎯 Natural! Đang tính toán kết quả...';
                        await this.sleep(1500);
                        this.finishGame();
                        return;
                    }

                    // Third card rules
                    await this.applyThirdCardRules();
                    
                    // Add dramatic pause before revealing results
                    await this.sleep(1000);
                    document.getElementById('gameResult').textContent = '⚡ Đang tính toán kết quả từ blockchain...';
                    await this.sleep(1500);
                    
                    this.finishGame();
                    
                } catch (error) {
                    console.error('VRF Error:', error);
                    document.getElementById('gameResult').textContent = '❌ Lỗi VRF, sử dụng fallback randomness...';
                    
                    // Fallback to local randomness if VRF fails
                    this.createDeck();
                    this.shuffleDeck();
                    await this.dealInitialCards();
                    await this.applyThirdCardRules();
                    this.finishGame();
                }
            }

            async dealInitialCards() {
                // Deal 2 cards to player and banker alternately with realistic timing
                await this.dealCard('player');
                await this.sleep(800);
                await this.dealCard('banker');
                await this.sleep(800);
                await this.dealCard('player');
                await this.sleep(800);
                await this.dealCard('banker');
                await this.sleep(500);
            }

            async dealCard(to) {
                const card = this.deck.pop();
                if (to === 'player') {
                    this.playerCards.push(card);
                } else {
                    this.bankerCards.push(card);
                }
                
                await this.animateCardDeal(card, to);
                this.updateScores();
            }

            async animateCardDeal(card, to) {
                // Play card deal sound
                this.sounds.cardDeal?.();
                
                // Create dealing animation
                const dealerHand = document.getElementById('dealerHand');
                const dealingCard = document.createElement('div');
                dealingCard.className = 'dealing-card';
                dealingCard.innerHTML = '🂠';
                dealerHand.appendChild(dealingCard);

                // Calculate target position
                const targetContainer = to === 'player' ? 
                    document.getElementById('playerCards') : 
                    document.getElementById('bankerCards');

                const dealerRect = dealerHand.getBoundingClientRect();
                const targetRect = targetContainer.getBoundingClientRect();
                
                const deltaX = targetRect.left - dealerRect.left + (targetContainer.children.length * 85);
                const deltaY = targetRect.top - dealerRect.top;

                // Animate the dealing
                dealingCard.style.opacity = '1';
                dealingCard.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.8s ease';
                
                await this.sleep(100);
                
                dealingCard.style.transform = `translateX(${deltaX}px) translateY(${deltaY}px) rotateZ(${Math.random() * 20 - 10}deg)`;
                
                await this.sleep(800);
                
                // Remove dealing card and create actual card
                dealerHand.removeChild(dealingCard);
                this.displayCard(card, to);
            }

            displayCard(card, to) {
                const cardElement = document.createElement('div');
                cardElement.className = `card ${card.suit === '♥' || card.suit === '♦' ? 'red' : ''}`;
                
                cardElement.innerHTML = `
                    <div class="card-inner">
                        <div class="card-back">
                            ♠♥♦♣
                        </div>
                        <div class="card-front">
                            <div class="card-rank-top">${card.rank}</div>
                            <div class="card-suit-center">${card.suit}</div>
                            <div class="card-rank-bottom">${card.rank}</div>
                        </div>
                    </div>
                `;
                
                const container = to === 'player' ? 
                    document.getElementById('playerCards') : 
                    document.getElementById('bankerCards');
                
                container.appendChild(cardElement);
                
                // Start with card face down, then flip after short delay (fixed order)
                setTimeout(() => {
                    cardElement.classList.add('flipped');
                    this.sounds.cardFlip?.(); // Play flip sound
                }, 200);

                // Add hover effect for better interaction
                cardElement.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-10px) rotateX(15deg) rotateY(5deg)';
                });
                
                cardElement.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0) rotateX(0deg) rotateY(0deg)';
                });
            }

            async applyThirdCardRules() {
                const playerScore = this.calculateScore(this.playerCards);
                const bankerScore = this.calculateScore(this.bankerCards);
                
                let playerThirdCard = null;
                
                // Player third card rule
                if (playerScore <= 5) {
                    await this.sleep(1000);
                    await this.dealCard('player');
                    playerThirdCard = this.playerCards[2];
                }
                
                // Banker third card rules
                const newPlayerScore = this.calculateScore(this.playerCards);
                let bankerShouldDraw = false;
                
                if (this.bankerCards.length === 2) { // Banker hasn't drawn yet
                    if (playerThirdCard === null) {
                        // Player didn't draw, banker draws if score <= 5
                        bankerShouldDraw = bankerScore <= 5;
                    } else {
                        // Player drew third card, complex banker rules
                        const thirdCardValue = playerThirdCard.value;
                        
                        if (bankerScore <= 2) bankerShouldDraw = true;
                        else if (bankerScore === 3) bankerShouldDraw = thirdCardValue !== 8;
                        else if (bankerScore === 4) bankerShouldDraw = [2,3,4,5,6,7].includes(thirdCardValue);
                        else if (bankerScore === 5) bankerShouldDraw = [4,5,6,7].includes(thirdCardValue);
                        else if (bankerScore === 6) bankerShouldDraw = [6,7].includes(thirdCardValue);
                    }
                    
                    if (bankerShouldDraw) {
                        await this.sleep(1000);
                        await this.dealCard('banker');
                    }
                }
            }

            finishGame() {
                this.gameState = 'finished';
                
                const playerScore = this.calculateScore(this.playerCards);
                const bankerScore = this.calculateScore(this.bankerCards);
                
                let winner;
                if (playerScore > bankerScore) {
                    winner = 'player';
                    this.stats.playerWins++;
                    document.getElementById('gameResult').textContent = '🎭 PLAYER THẮNG! (VRF Verified)';
                    document.getElementById('gameResult').className = 'result-display winner';
                } else if (bankerScore > playerScore) {
                    winner = 'banker';
                    this.stats.bankerWins++;
                    document.getElementById('gameResult').textContent = '🏦 BANKER THẮNG! (VRF Verified)';
                    document.getElementById('gameResult').className = 'result-display winner';
                } else {
                    winner = 'tie';
                    this.stats.ties++;
                    document.getElementById('gameResult').textContent = '🤝 HÒA! (VRF Verified)';
                    document.getElementById('gameResult').className = 'result-display tie';
                }
                
                // Log game result
                this.addConsoleLog(`🏁 Game finished! Winner: ${winner.toUpperCase()}`, 'success');
                this.addConsoleLog(`📊 Final scores - Player: ${playerScore}, Banker: ${bankerScore}`, 'info');
                
                if (this.vrfRequestId) {
                    this.addConsoleLog(`🔐 Result verified by VRF: ${this.vrfRequestId}`, 'success');
                }
                
                // Check player's personal bets and show personalized message
                this.showPersonalizedMessage(winner);
                
                // Play win sound and create celebration effects
                this.sounds.win?.();
                this.createWinEffects(winner);
                this.addWinnerGlow(winner);
                
                this.stats.totalGames++;
                this.updateStats();
                this.calculatePayouts(winner);
                
                // Auto reset after 8 seconds (longer to read message)
                setTimeout(() => {
                    this.resetGame();
                }, 8000);
            }

            showPersonalizedMessage(winner) {
                const playerBetAmount = this.currentGameBets[winner] || 0;
                const playerLostBets = Object.keys(this.currentGameBets)
                    .filter(bet => bet !== winner)
                    .reduce((sum, bet) => sum + this.currentGameBets[bet], 0);
                
                let message, emoji, messageClass, amount;
                
                if (playerBetAmount > 0) {
                    // Player won
                    const winnings = winner === 'tie' ? playerBetAmount * 8 : playerBetAmount * 2;
                    const profit = winnings - (playerBetAmount + playerLostBets);
                    
                    this.addConsoleLog(`🎉 Player WON! Bet: ${playerBetAmount} ETH on ${winner.toUpperCase()}`, 'success');
                    this.addConsoleLog(`💰 Total winnings: ${winnings} ETH (${profit > 0 ? '+' : ''}${profit} ETH profit)`, 'success');
                    
                    emoji = profit > 0 ? '🎉' : '😊';
                    message = profit > 0 ? 
                        `Chúc mừng! Bạn đã thắng!<br/>Lợi nhuận: ${profit.toFixed(2)} ETH` :
                        `Bạn đã thắng cược!<br/>Hoà vốn thật tuyệt!`;
                    amount = `Tiền thắng: ${winnings.toFixed(2)} ETH`;
                    messageClass = 'win';
                    
                } else if (playerLostBets > 0) {
                    // Player lost
                    this.addConsoleLog(`😢 Player lost ${playerLostBets} ETH this round`, 'warning');
                    
                    const encouragements = [
                        'Đừng nản chí! Ván sau sẽ may mắn hơn!',
                        'Cơ hội luôn có! Hãy thử lại nhé!',
                        'Kiên nhẫn là chìa khóa thành công!',
                        'Mỗi ván chơi là một cơ hội mới!',
                        'Vận may sẽ quay lại với bạn!'
                    ];
                    
                    emoji = '💪';
                    message = encouragements[Math.floor(Math.random() * encouragements.length)];
                    amount = `Tiếp tục cố gắng!`;
                    messageClass = 'lose';
                    
                } else {
                    // Player didn't bet this round
                    this.addConsoleLog('👀 Player observed this round without betting', 'info');
                    
                    emoji = '👀';
                    message = 'Quan sát kỹ để cơ hội tiếp theo!<br/>Hãy đặt cược ván sau nhé!';
                    amount = 'Chờ cơ hội tốt';
                    messageClass = 'info';
                }
                
                this.displayPersonalMessage(emoji, message, amount, messageClass);
            }

            displayPersonalMessage(emoji, message, amount, messageClass) {
                const messageElement = document.getElementById('personalMessage');
                const emojiElement = document.getElementById('messageEmoji');
                const textElement = document.getElementById('messageText');
                const amountElement = document.getElementById('messageAmount');
                
                emojiElement.textContent = emoji;
                textElement.innerHTML = message;
                amountElement.textContent = amount;
                
                messageElement.className = `personal-message ${messageClass}`;
                messageElement.classList.add('show');
                
                // Hide after 5 seconds
                setTimeout(() => {
                    messageElement.classList.remove('show');
                }, 5000);
            }

            createWinEffects(winner) {
                // Create confetti for big wins
                if (winner !== 'tie') {
                    this.createConfetti();
                }
                
                // Create particle explosion at result display
                const resultDisplay = document.getElementById('gameResult');
                const rect = resultDisplay.getBoundingClientRect();
                
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = `particle ${winner === 'player' ? 'gold' : winner === 'banker' ? 'silver' : 'red'}`;
                        particle.style.position = 'fixed';
                        particle.style.left = (rect.left + rect.width/2 + (Math.random() - 0.5) * 100) + 'px';
                        particle.style.top = (rect.top + rect.height/2) + 'px';
                        particle.style.width = (8 + Math.random() * 8) + 'px';
                        particle.style.height = particle.style.width;
                        particle.style.zIndex = '1000';
                        
                        document.body.appendChild(particle);
                        
                        setTimeout(() => {
                            if (document.body.contains(particle)) {
                                document.body.removeChild(particle);
                            }
                        }, 2000);
                    }, i * 50);
                }
            }

            createConfetti() {
                const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'];
                
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const confetti = document.createElement('div');
                        confetti.className = 'confetti';
                        confetti.style.position = 'fixed';
                        confetti.style.left = Math.random() * window.innerWidth + 'px';
                        confetti.style.top = '-10px';
                        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                        confetti.style.width = (5 + Math.random() * 10) + 'px';
                        confetti.style.height = confetti.style.width;
                        confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                        confetti.style.animation = `confetti-fall ${2 + Math.random() * 3}s linear forwards`;
                        confetti.style.zIndex = '999';
                        
                        document.body.appendChild(confetti);
                        
                        setTimeout(() => {
                            if (document.body.contains(confetti)) {
                                document.body.removeChild(confetti);
                            }
                        }, 5000);
                    }, i * 100);
                }
            }

            addWinnerGlow(winner) {
                const winnerArea = winner === 'player' ? 
                    document.querySelector('[data-bet="player"]') :
                    winner === 'banker' ? 
                    document.querySelector('[data-bet="banker"]') :
                    document.querySelector('[data-bet="tie"]');
                
                if (winnerArea) {
                    winnerArea.classList.add('winner-glow');
                    setTimeout(() => {
                        winnerArea.classList.remove('winner-glow');
                    }, 3000);
                }
            }

            calculatePayouts(winner) {
                const totalPool = Object.values(this.bets).reduce((sum, bet) => sum + bet, 0);
                const houseRake = totalPool * 0.03; // 3% DAO fee
                const payoutPool = totalPool - houseRake;
                
                console.log(`Winner: ${winner}`);
                console.log(`Total Pool: ${totalPool} ETH`);
                console.log(`House Rake: ${houseRake} ETH`);
                console.log(`Payout Pool: ${payoutPool} ETH`);
                
                // In real implementation, this would distribute to winners
            }

            updateScores() {
                document.getElementById('playerScore').textContent = this.calculateScore(this.playerCards);
                document.getElementById('bankerScore').textContent = this.calculateScore(this.bankerCards);
            }

            updateDisplay() {
                const playerBetElement = document.getElementById('playerBet');
                const bankerBetElement = document.getElementById('bankerBet');
                const tieBetElement = document.getElementById('tieBet');
                
                if (playerBetElement) playerBetElement.textContent = this.bets.player + ' ETH';
                if (bankerBetElement) bankerBetElement.textContent = this.bets.banker + ' ETH';
                if (tieBetElement) tieBetElement.textContent = this.bets.tie + ' ETH';
                
                const totalPool = Object.values(this.bets).reduce((sum, bet) => sum + bet, 0);
                
                const totalPoolElement = document.getElementById('totalPool');
                const playersCountElement = document.getElementById('playersCount');
                
                if (totalPoolElement) totalPoolElement.textContent = totalPool + ' ETH';
                if (playersCountElement) playersCountElement.textContent = this.playersCount;
                
                console.log('Display updated:', {
                    playerBet: this.bets.player,
                    bankerBet: this.bets.banker,
                    tieBet: this.bets.tie,
                    totalPool: totalPool,
                    playersCount: this.playersCount
                });
            }

            updateStats() {
                document.getElementById('playerWins').textContent = this.stats.playerWins;
                document.getElementById('bankerWins').textContent = this.stats.bankerWins;
                document.getElementById('ties').textContent = this.stats.ties;
                document.getElementById('totalGames').textContent = this.stats.totalGames;
            }

            resetGame() {
                clearInterval(this.timer);
                this.gameState = 'betting';
                this.playerCards = [];
                this.bankerCards = [];
                this.bets = { player: 0, banker: 0, tie: 0 };
                this.selectedBet = null;
                this.playersCount = 0;
                this.timeLeft = 30;
                
                document.getElementById('playerCards').innerHTML = '';
                document.getElementById('bankerCards').innerHTML = '';
                document.getElementById('playerScore').textContent = '0';
                document.getElementById('bankerScore').textContent = '0';
                document.getElementById('gameResult').textContent = 'Chờ người chơi đặt cược...';
                document.getElementById('gameResult').className = 'result-display';
                document.getElementById('dealBtn').disabled = true;
                
                document.querySelectorAll('.bet-area').forEach(area => {
                    area.classList.remove('selected');
                });
                
                this.createDeck();
                this.shuffleDeck();
                this.updateDisplay();
                this.startBettingTimer();
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            const game = new BaccaratGame();
            
            // Enable audio on first user interaction
            document.addEventListener('click', function enableAudio() {
                if (game.audioContext && game.audioContext.state === 'suspended') {
                    game.audioContext.resume();
                }
                document.removeEventListener('click', enableAudio);
            });
        });
    </script>
</body>
</html>